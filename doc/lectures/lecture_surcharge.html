<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>Surdéfinition d&rsquo;opérateur</title>
<meta  name="generator" content="Org-mode" />
<link rel="stylesheet" href="../stylesheets/styles.css">
                 <link rel="stylesheet" href="../stylesheets/org-pygments.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="preamble" class="status">
</a><a href="lecture_pointeur.html">Pointeurs, références & allocation dynamique </a><a href="lecture_fonction.html">Rappels sur les fonctions </a><a href="lecture_specificite_c++.html">Les spécificités du C++ </a><a href="lecture_struct_class.html">Structures et classes </a><a href="lecture_encapsulation.html">Encapsulation des données </a><a href="lecture_constructeur.html">Notions de constructeur et de destructeur </a><a href="lecture_amitie.html">Fonctions et classes amies </a><a href="lecture_surcharge.html">Surcharge d'opérateur </a><a href="lecture_heritage.html">Héritage </a><a href="lecture_template.html">Notions de patrons de fonctions et de classes </a><a href="lecture_librairie_standard.html">Introduction à la librairie standard STL </a><a href=""></a><hr/><a href="annexe_compilation.html">Compilation et directives de préprocesseur </a><a href="annexe_convention_ecriture.html">Convention d'écriture et organisation des programmes </a><a href="annexe_cout_cin.html">Écriture/lecture sur l'entrée/sortie standard </a><a href="annexe_variable_statique.html">Les membres données statiques </a><a href="annexe_enum_typedef.html">Utilisation de enum et de typedef </a>
                    <hr/>
                    <a href="../../index.html">Retour menu principal</a>
</div>
<div id="content">
<h1 class="title">Surdéfinition d&rsquo;opérateur</h1><hr/>
<p>
Le C++ permet de surdéfinir les opérateurs<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> c&rsquo;est-à-dire de donner un sens
différent à un symbole selon le contexte. Cette possibilité tient au fait que
les opérateurs ne se différencient des fonctions que syntaxiquement, pas
logiquement. À ce titre, le compilateur traite un appel à un opérateur comme un
appel à une fonction. On pourra donc surdéfinir ou surcharger un opérateur dès
lors que la nouvelle définition se différenciera, sans ambiguité, des
précédentes. Par exemple, surdéfinir l&rsquo;opérateur <code>+</code> permet que l&rsquo;addition
<i>i.e.</i> le symbole <code>+</code> binaire, n&rsquo;ait pas le même sens s&rsquo;il agit sur deux entiers
ou si l&rsquo;addition porte sur deux objets de la classe <code>point</code>.
</p>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">Surcharge des opérateurs internes</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
Une première méthode pour surcharger les opérateurs consiste à les considérer
comme des méthodes de la classe sur laquelle ils s&rsquo;appliquent. Le nom de ces
méthodes est donné par le mot clé <code>operator</code>, suivi de l&rsquo;opérateur à
surcharger. Le type de la fonction est le type du résultat donné par
l&rsquo;opération, et les paramètres, donnés en argument, sont les opérandes. La
syntaxe est la suivante :
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">type</span> <span class="org-function-name">operatorOp</span>(argument)
</pre>
</div>
<p>
L&rsquo;écriture <code>A Op B</code> où <code>Op</code> est, par exemple, <code>+,</code>,*==&#x2026; se traduit par
</p>
<div class="org-src-container">

<pre class="src src-c++">A.operatorOp(B)
</pre>
</div>
<p>
Le premier opérande est toujours l&rsquo;objet auquel cette fonction s&rsquo;applique. Cette
manière de surcharger les opérateurs est donc particulièrement adaptée pour les
opérateurs qui modifient l&rsquo;objet sur lequel ils travaillent tels que les
opérateurs <code>=, +</code>, ++=&#x2026;. Par ailleurs, les opérateurs (sur)définis en
interne devront souvent renvoyer l&rsquo;objet sur lequel ils travaillent (ce n&rsquo;est
pas une nécessité cependant). On utilisera alors le pointeur <code>this</code> qui pointe
sur l&rsquo;adresse de l&rsquo;objet qui a appelé la méthode de surdéfinition.
</p>

<p>
Afin d&rsquo;illustrer les propriétés définies dans ce paragraphe, nous proposons
quelques exemples d&rsquo;implémentation de surdéfinition d&rsquo;opérateurs en relation
avec la classe <code>complexe</code>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">class</span> <span class="org-type">complexe</span> {
<span class="org-keyword">public</span>:
  <span class="org-function-name">complexe</span>(<span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">reel</span>, <span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">img</span>);
  <span class="org-type">complexe</span> &amp; <span class="org-keyword">operator</span><span class="org-function-name">+=</span>(<span class="org-keyword">const</span> <span class="org-type">complexe</span>&amp; <span class="org-variable-name">source</span>);
  <span class="org-type">complexe</span> &amp; <span class="org-keyword">operator</span><span class="org-function-name">*=</span>(<span class="org-keyword">const</span> <span class="org-type">complexe</span>&amp; <span class="org-variable-name">source</span>);
  ...

  <span class="org-keyword">private</span>:
  <span class="org-type">double</span> <span class="org-variable-name">m_reel</span>;
  <span class="org-type">double</span> <span class="org-variable-name">m_imaginaire</span>;
};

<span class="org-constant">complexe</span>::<span class="org-function-name">complexe</span>(<span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">reel</span>, <span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">img</span>) :
  m_reel(reel), m_imaginaire(img) {}

<span class="org-type">complexe</span> &amp; <span class="org-constant">complexe</span>::<span class="org-keyword">operator</span><span class="org-function-name">+=</span>(<span class="org-keyword">const</span> <span class="org-type">complexe</span> &amp; <span class="org-variable-name">source</span>)
{
  m_reel       += source.m_reel;
  m_imaginaire += source.m_imaginaire;
  <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
}

<span class="org-type">complexe</span> &amp; <span class="org-constant">complexe</span>::<span class="org-keyword">operator</span><span class="org-function-name">*=</span>(<span class="org-keyword">const</span> <span class="org-type">complexe</span> &amp; <span class="org-variable-name">source</span>)
{
  <span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">tmp</span> = m_reel*source.m_reel - m_imaginaire*source.m_imaginaire;
  m_imaginaire = m_reel*source.m_imaginaire + m_imaginaire*source.m_reel;
  m_reel = tmp;
  <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
}
</pre>
</div>

<div class="REMARK">
<p>
Comme pour toute surdéfinition de fonction, le compilateur choisit, selon le
contexte, quelle surcharge d&rsquo;opérateur utiliser. Ainsi, on pourra, selon les
besoins, surcharger l&rsquo;opérateur <i><code>+=</code></i> de l&rsquo;exemple précédent en fournissant en
argument non plus un objet <i><code>Complexe</code></i> sinon un entier ou un double. La
définition de la méthode sera
</p>
<div class="org-src-container">

<pre class="src src-c++">complexe&amp; <span class="org-keyword">operator</span>+=(<span class="org-keyword">const</span> <span class="org-type">double</span>&amp; <span class="org-variable-name">a</span>);
</pre>
</div>

</div>
</div>
</div>



<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">Surcharge des opérateurs en externe</h2>
<div class="outline-text-2" id="text-orgheadline2">
<p>
La définition de l&rsquo;opérateur ne se fait plus dans la classe qui l&rsquo;utilise, mais
en dehors de celle-ci par surcharge d&rsquo;un opérateur de l&rsquo;espace de
nommage. L&rsquo;opérateur surdéfini est déclaré comme une fonction travaillant avec
la classe dont l&rsquo;opérateur doit être surchargé. Pour que cette fonction puisse
accéder aux membres de la classe, elle est généralement définie comme fonction
amie (<code>friend</code>). Le prototype est le suivant
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-keyword">friend</span> <span class="org-type">type</span> <span class="org-function-name">operatorOp</span>(argument);
</pre>
</div>

<p>
À titre d&rsquo;exemple, on pourra surcharger l&rsquo;opérateur <code>+</code> de la classe <code>complexe</code>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">complexe</span> <span class="org-keyword">operator</span><span class="org-function-name">+</span>(<span class="org-keyword">const</span> <span class="org-type">complexe</span> &amp; <span class="org-variable-name">z1</span>, <span class="org-keyword">const</span> <span class="org-type">complexe</span> &amp; <span class="org-variable-name">z2</span>) <span class="org-keyword">const</span>
{
  <span class="org-keyword">return</span> complexe(z1.m_reel + z2.m_reel, z1.m_imaginaire + z2.m_imaginaire);
}
</pre>
</div>

<div class="REMARK">
<p>
On notera bien que la surcharge de l&rsquo;opérateur est extérieure à la classe
<i><code>complexe</code></i> : sa déclaration ne fait pas intervenir l&rsquo;opérateur de portée
<i><code>::</code></i>. Par ailleurs, la déclaration précédente suppose que la construction
<i><code>complexe(const double, const double)</code></i> est envisageable.
</p>

</div>

<p>
L&rsquo;avantage de cette syntaxe est que l&rsquo;opérateur est réellement symétrique,
contrairement au cas où les opérateurs sont définis à l&rsquo;intérieur de la classe.
</p>
</div>

<div id="outline-container-orgheadline3" class="outline-4">
<h4 id="orgheadline3">Remarques importantes</h4>
<div class="outline-text-4" id="text-orgheadline3">
<ul class="org-ul">
<li>Lorsque l&rsquo;on surdéfinit un opérateur, c&rsquo;est à priori pour l&rsquo;utiliser à
plusieurs reprises. Il faut donc apporter un soin particulier à l&rsquo;optimisation
du code. En conséquence, il est important de savoir si l&rsquo;on déclare ou non la
fonction <code>inline</code></li>

<li><p>
Dans le cas d&rsquo;opérateur unaire tel que l&rsquo;opérateur <code>-()</code> qui effectue la
transformation \(z\mapsto-z\), la (sur)définition de la fonction ne prend
pas d&rsquo;argument. On écrit alors
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">complexe</span>&amp; <span class="org-keyword">operator</span><span class="org-function-name">-</span>() <span class="org-keyword">const</span>
{
  <span class="org-keyword">return</span> complexe(-m_reel, -m_imaginaire);
}
</pre>
</div></li>

<li>De manière générale, si une méthode ne modifie pas les membres de la classe,
on ajoute à la fin de sa définition, le mot clé <code>const</code> (<i>cf.</i> exemple
précédent). Cette remarque prend toute son importance lorsque l&rsquo;on manipule
les opérateurs permettant ainsi de s&rsquo;assurer que les membres ne sont pas
modifiés de manière inopportune.</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4">Constructeur de recopie et opérateur d&rsquo;affectation <code>=</code></h2>
<div class="outline-text-2" id="text-orgheadline4">
<p>
L&rsquo;opérateur d&rsquo;affectation <code>=</code> peut lui aussi être redéfini. Cependant, son rôle
peut parfois interférer avec celui du constructeur de recopie. De même que le
constructeur est la fonction appelée lors de la création d&rsquo;un objet, le
constructeur de recopie est appelé lors de la copie d&rsquo;un objet vers un autre
objet du même type (<i>e.g.</i> une instruction du type <code>z1 = z2;</code> où <code>z1</code> et <code>z2</code> sont
des instances de la classe <code>complexe</code>).
</p>

<p>
La définition du constructeur de recopie est voisine de celle du constructeur
par défaut sachant toutefois que le constructeur de recopie possède comme
argument <b>une référence vers la classe</b>. Ainsi, son prototype s&rsquo;écrit:
</p>
<div class="org-src-container">

<pre class="src src-c++">nom_classe(<span class="org-type">nom_classe</span> &amp;);
</pre>
</div>
<p>
tandis que sa déclaration est
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-constant">nom_classe</span>::nom_classe(nom_classe &amp; objet_de_type_nom_classe);
</pre>
</div>

<p>
Exemple:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-constant">complexe</span>::<span class="org-function-name">complexe</span>(<span class="org-keyword">const</span> <span class="org-type">complexe</span> &amp; <span class="org-variable-name">source</span>)
{
  m_reel       = source.m_reel;
  m_imaginaire = source.m_imaginaire;
}
</pre>
</div>

<p>
L&rsquo;opérateur d&rsquo;affectation <code>=</code> se définit comme toute surcharge d&rsquo;opérateur et sa
déclaration devient
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">complexe</span>&amp; <span class="org-constant">complexe</span>::<span class="org-keyword">operator</span><span class="org-function-name">=</span>(<span class="org-keyword">const</span> <span class="org-type">complexe</span> &amp; <span class="org-variable-name">source</span>)
{
  <span class="org-keyword">if</span> (&amp;source != <span class="org-keyword">this</span>) {
    m_reel       = source.m_reel;
    m_imaginaire = source.m_imaginaire;
  }
  <span class="org-keyword">return</span> *<span class="org-keyword">this</span>;
}
</pre>
</div>

<p>
Du point de vue de la syntaxe, la surcharge d&rsquo;opérateur d&rsquo;affectation est
voisine de celle du constructeur de recopie. Néanmoins, la surcharge de
l&rsquo;opérateur d&rsquo;affectation signale bien souvent que la classe n&rsquo;a pas une
structure simple (présence d&rsquo;un pointeur en particulier) et qu&rsquo;en conséquence,
le constructeur de recopie et le destructeur par défaut, fournis par le
compilateur, ne suffisent pas. Il faut donc veiller à respecter la règle des
trois, qui stipule que si l&rsquo;une des ces méthodes est redéfinie, il faut que les
trois le soient. Par ailleurs, si le constructeur de recopie n&rsquo;est pas redéfini,
les écritures telles que :
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">classe</span> <span class="org-variable-name">objet</span> = source;
</pre>
</div>
<p>
ne fonctionnent pas correctement. En effet, c&rsquo;est le constructeur de recopie qui
est appelé dans ce cas, et non l&rsquo;opérateur d&rsquo;affectation comme le suggère la
syntaxe.
</p>

<p>
Un autre problème important tient à l&rsquo;autoaffectation. Non seulement affecter un
objet à lui-même est inutile et consommateur de ressources, mais de plus, cela
peut s&rsquo;avérer dangereux : l&rsquo;affectation risque de détruire les données membres
de l&rsquo;objet avant même qu&rsquo;elles ne soient copiées, ce qui provoque au final ni
plus ni moins que la destruction de l&rsquo;objet. Une solution simple présentée dans
l&rsquo;exemple précédent consiste à ajouter un test sur l&rsquo;objet source en début de
surcharge d&rsquo;opérateur : <code>if (&amp;source !=</code> <code>this)</code>.
</p>

<p>
Pour toutes ces raisons, la surcharge de l&rsquo;opérateur d&rsquo;affectation s&rsquo;avère une
opération souvent délicate. Dans la grande majorité des cas, on évitera de
surcharger l&rsquo;opérateur d&rsquo;affectation en utilisant le constructeur de recopie par
défaut.
</p>
</div>

<div id="outline-container-orgheadline5" class="outline-4">
<h4 id="orgheadline5">Remarques générales</h4>
<div class="outline-text-4" id="text-orgheadline5">
<ul class="org-ul">
<li>l&rsquo;opérateur <code>()</code> est intéressant car il est &ldquo;n-unaire&rdquo;.</li>

<li>il est aussi possible de surdéfinir :
<ul class="org-ul">
<li>les opérateurs de transtypage (ou de casting)</li>
<li>les opérateurs de déférencement <code>*</code> et d&rsquo;indirection <code>&amp;</code></li>
<li><code>new</code> et <code>delete</code></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Notes : </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
on parle également de surcharge d&rsquo;opérateur
</p></div></div>


</div>
</div></div>
</body>
</html>
