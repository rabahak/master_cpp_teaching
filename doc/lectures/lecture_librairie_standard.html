<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Introduction à la librairie standard STL</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<link rel="stylesheet" href="../stylesheets/styles.css">
                 <link rel="stylesheet" href="../stylesheets/org-pygments.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
</a><a href="lecture_pointeur.html">Pointeurs, références & allocation dynamique </a><a href="lecture_fonction.html">Rappels sur les fonctions </a><a href="lecture_specificite_c++.html">Les spécificités du C++ </a><a href="lecture_struct_class.html">Structures et classes </a><a href="lecture_encapsulation.html">Encapsulation des données </a><a href="lecture_constructeur.html">Notions de constructeur et de destructeur </a><a href="lecture_amitie.html">Fonctions et classes amies </a><a href="lecture_surcharge.html">Surcharge d'opérateur </a><a href="lecture_heritage.html">Héritage </a><a href="lecture_template.html">Notions de patrons de fonctions et de classes </a><a href="lecture_librairie_standard.html">Introduction à la librairie standard STL </a><a href=""></a><hr/><a href="annexe_compilation.html">Compilation et directives de préprocesseur </a><a href="annexe_convention_ecriture.html">Convention d'écriture et organisation des programmes </a><a href="annexe_cout_cin.html">Écriture/lecture sur l'entrée/sortie standard </a><a href="annexe_variable_statique.html">Les membres données statiques </a><a href="annexe_enum_typedef.html">Utilisation de enum et de typedef </a>
                    <hr/>
                    <a href="../../index.html">Retour menu principal</a>
</div>
<div id="content">
<h1 class="title">Introduction à la librairie standard STL</h1><hr/>
<p>
Le langage C++ en lui-même ne fournit que très peu d&rsquo;outils pour la gestion des
chaînes de caractères, les entrées/sorties et les collections (que l&rsquo;on regroupe
communément sous l&rsquo;appelation de containers), car il n&rsquo;ajoute pour ces besoins
rien par rapport au C.
</p>

<p>
La librairie standard STL (<i>Standard Template Library</i>) du C++ apporte donc une
réponse standardisée et exploitant très largement les mécanismes étendus du C++
par rapport à C, que sont :
</p>

<ul class="org-ul">
<li>l&rsquo;approche objet et les capacités d&rsquo;abstraction en particulier sur les
opérateurs,
</li>

<li>les patrons de classe,
</li>

<li>la surdéfinition des opérateurs.
</li>
</ul>

<p>
Cette bibliothèque implémente un grand nombre de classe patron décrivant des
containers génériques pour le langage C++ afin de pallier aux limitations
intrinsèques au langage C. La STL fournit de plus des algorithmes permettant de
manipuler aisément ces containers (pour les initialiser, rechercher des valeurs,
&#x2026;). D&rsquo;autre part, la STL introduit également le concept d&rsquo;itérateur qui permet
de parcourir très facilement un container en s&rsquo;affranchissant complètement de la
manière dont il est implémenté.
</p>

<p>
L&rsquo;objectif de cette introduction n&rsquo;est pas de faire un inventaire exhaustif des
possibilités offertes par la STL, mais d&rsquo;en donner un aperçu au travers
d&rsquo;exemples courants d&rsquo;utilisation. On pourra trouver le détail des classes de la
STL à l&rsquo;adresse suivante :
</p>

<div class="center">
<p>
<a href="http://www.sgi.com/tech/stl/table_of_contents.html">http://www.sgi.com/tech/stl/table_of_contents.html</a>
</p>
</div>

<div id="outline-container-unnumbered-1" class="outline-2">
<h2 id="unnumbered-1">Principales classes de la STL</h2>
<div class="outline-text-2" id="text-unnumbered-1">
<p>
Les types de données disponibles sont multiples; cependant, les trois
fréquemment utilisés sont le vecteur, la liste et la table associative. Pour
pouvoir bénéficier de leurs fonctionnalités, les fichiers d&rsquo;entêtes homonymes
doivent être inclus : on utilisera par exemple <code>#include &lt;vector&gt;</code> pour un
vecteur, <code>#include &lt;list&gt;</code> pour une liste, etc. Par ailleurs, l&rsquo;ensemble de ces
containers appartiennent à l&rsquo;espace de nom standard <code>std</code>.  Nous allons plus
spécifiquement discuter des vecteurs et des listes chainées (<code>string</code>), les
opérations sur les autres conteneurs étant similaires du fait de leur
implémentation.
</p>
</div>

<div id="outline-container-unnumbered-2" class="outline-3">
<h3 id="unnumbered-2">La classe <code>vector</code></h3>
<div class="outline-text-3" id="text-unnumbered-2">
<p>
La classe <code>vector</code> est proche du tableau du C. Tous les éléments contenus dans
le <code>vector</code> sont adjacents en mémoire, ce qui permet d&rsquo;accéder immédiatement à
n&rsquo;importe quel élément. L&rsquo;avantage majeur du <code>vector</code> comparé au tableau du C
réside dans sa faculté à se réallouer automatiquement en cas de besoin lors de
l&rsquo;utilisation de la méthode <code>push_back</code> par exemple. La désallocation est
également simplifiée de par l&rsquo;existence du destructeur de classe. Cependant,
contrairement à un tableau classique, une case n&rsquo;est accessible par l&rsquo;opérateur
<code>[]</code> que si elle a été allouée au préalable (sinon une erreur de segmentation se
déclenche).
</p>

<p>
L&rsquo;exemple ci-dessous présente les principales méthodes issues de la
classe <code>vector</code>
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">D&#233;claration d'un vecteur d'entiers de taille non connue</span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">myVector</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Ajout de trois &#233;l&#233;ments</span>
  myVector.push_back(4);
  myVector.push_back(2);
  myVector.push_back(5);

  <span class="org-comment-delimiter">// </span><span class="org-comment">La m&#233;thode size pr&#233;cise le nombre d'entr&#233;e courante</span>
  <span class="org-keyword">for</span> (<span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">iEntry</span> = 0; iEntry &lt; myVector.size(); ++iEntry)
    <span class="org-constant">std</span>::cout &lt;&lt; iEntry &lt;&lt; <span class="org-string">" "</span> &lt;&lt; myVector[iEntry] &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Cr&#233;ation d'un vecteur d'entier contenant 70,70,70,70,70</span>
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">mySecondVector</span>(5,70);

  <span class="org-comment-delimiter">// </span><span class="org-comment">R&#233;assignation des valeurs de ce vecteur</span>
  mySecondVector[0] = 5;
  mySecondVector[1] = 3;
  mySecondVector[2] = 7;
  mySecondVector[3] = 4;
  mySecondVector[4] = 8;

  mySecondVector.clear();
  <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<p>
Parmi les quelques instructions présentées, on distingue l&rsquo;utilisation de la
méthode <code>push_back</code> qui permet d&rsquo;ajouter un élément en fin de vecteur tout en
réallouant l&rsquo;espace mémoire nécessaire. La méthode <code>push_front</code> réalise
l&rsquo;opération inverse à savoir l&rsquo;ajout d&rsquo;une entrée en début de vecteur. Du fait
du déplacement de l&rsquo;ensemble des valeurs précédemment assignées et allouées en
mémoire, cette méthode nécessite un temps plus conséquent afin de réorganiser la
structure en mémoire du vecteur.
</p>

<p>
On note également l&rsquo;utilisation de la méthode <code>size</code> qui permet de déterminer le
nombre d&rsquo;élément courramment alloué. Il est ainsi possible de parcourir
l&rsquo;ensemble des valeurs &ldquo;recueillies&rdquo; jusqu&rsquo;à présent (nous verrons à la fin de
ce cours, que la notion d&rsquo;itérateur généralise ce mécanisme indépendamment de la
classe mise en jeu).
</p>

<p>
Comme nous le soulignions précédemment, l&rsquo;opérateur <code>[]</code> est également
accessible rendant l&rsquo;utilisation de la classe <code>vector</code> similaire au tableau. On
remarquera toutefois qu&rsquo;il existe la méthode <code>at</code> dont la finalité est identique
à l&rsquo;opérateur <code>[]</code> mais qui vérifie préalablement l&rsquo;existence de l&rsquo;élément. Dans
le cas d&rsquo;un dépassement de mémoire, le programme stoppe de manière plus élégante
qu&rsquo;un <code>segmentation fault</code> en précisant l&rsquo;origine de l&rsquo;arrêt. Enfin, la méthode
<code>clear</code> permet de vider le vecteur de sa substance en ramenant sa taille à 0.
</p>

<div class="REMARK">
<p>
Il ne faut pas perdre de vue qu&rsquo;une réallocation mémoire est coûteuse en terme
de temps de calcul. Aussi, si la taille d&rsquo;un vecteur est connue par avance, il
faut autant que possible le créer directement à cette taille.
</p>

</div>
</div>
</div>

<div id="outline-container-unnumbered-3" class="outline-3">
<h3 id="unnumbered-3">La classe <code>string</code></h3>
<div class="outline-text-3" id="text-unnumbered-3">
<p>
Il est possible en C++ d&rsquo;utiliser les chaînes de caractères héritées du
C. Celui-ci ne disposant pas de type &ldquo;chaîne&rdquo; primitif (c&rsquo;est à dire intégré au
langage), celles-ci sont représentées sous forme de tableaux de caractères
terminés par un <code>\0</code> (caractère ASCII <code>0</code>). Le plus souvent, pour des
raisons de souplesse, les chaînes sont allouées dynamiquement : le type de
données représentant donc les chaînes de caractères en C est <code>char*</code> (qui
signifie pointeur sur caractère ou pointeur sur tableau de caractères : on ne
peut pas faire la différence en C). L&rsquo;ensemble des manipulations classiques sur
les chaînes de caractères est disponible à partir du fichier d&rsquo;entête <code>string.h</code>
(obtention de la longueur, concaténation, copie, segmentation,&#x2026;).
</p>

<p>
Cependant, le fait d&rsquo;utiliser une représentation aussi peu abstraite pose
beaucoup de problèmes en pratique : le code n&rsquo;est pas toujours lisible, et une
certaine attention est requise pour gérer convenablement la mémoire sous peine
d&rsquo;obtenir des fuites mémoire ou, plus grave, des segmentation faults. Afin de
manipuler plus aisément les chaîne de caractères, une classe <code>string</code> a été
définie et intégrée dans la librairie standard.
</p>

<p>
Les chaînes de caractères se trouvent dans le header <code>string</code> (à ne pas
confondre avec <code>string.h</code>, qui contient les fonctionnalités pour manipuler les
chaînes de caractères C). L&rsquo;exemple suivant présente quelques unes des
possibilités offertes par cette classe
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;string&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">Assignation/copie de strings</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">myString1</span> = <span class="org-string">"abcd"</span>;
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">myString2</span> = myString1;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Initialisation de strings</span>
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">myString3</span>(myString2);

  <span class="org-comment-delimiter">// </span><span class="org-comment">Concat&#233;nation</span>
  myString2 += <span class="org-string">"abcd"</span>;
  <span class="org-constant">std</span>::<span class="org-type">string</span> <span class="org-variable-name">myString4</span> = myString1 + <span class="org-string">"toto"</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Comparaison</span>
  <span class="org-keyword">const</span> <span class="org-type">bool</span> <span class="org-variable-name">myBoolean</span> = (myString1 == myString2);
  <span class="org-keyword">if</span> (myBoolean)
    <span class="org-constant">std</span>::cout &lt;&lt; myString1 &lt;&lt; <span class="org-string">" est identique &#224; "</span> &lt;&lt; myString2 &lt;&lt; <span class="org-constant">std</span>::endl;

  <span class="org-comment-delimiter">// </span><span class="org-comment">Longueur d'un string</span>
  <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">size</span> = myString1.size();

  <span class="org-comment-delimiter">// </span><span class="org-comment">Recherche dans un string</span>
  <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">pos</span> = myString1.find(<span class="org-string">"bc"</span>);
  <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<p>
On reconnaît entre autre la méthode <code>size</code> qui précise la taille <i>i.e.</i> le
nombre de caractère, d&rsquo;une instance de <code>string</code>. La surcharge des opérateurs
tels que <code>+=</code> ou <code>+</code> permet par ailleurs de concaténer des chaînes de caractères
tandis que la méthode <code>find</code> indique la position à laquelle est trouvée la
première occurence de la chaine de caractère fournie en argument.
</p>

<p>
Nous ne faisons ici, que citer certaines des méthodes les plus communément
utilisées. Le lecteur intéressé pourra se référer aux nombreux ouvrage ainsi
qu&rsquo;aux différentes pages internet traitant du sujet. Nous soulignerons
finalement la possibilité grâce au mécanisme des patrons de déclarer des
vecteurs de chaines de caractères <i>via</i> l&rsquo;instruction <code>vector&lt;string&gt;
myStringVector</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-unnumbered-4" class="outline-2">
<h2 id="unnumbered-4">Les itérateurs</h2>
<div class="outline-text-2" id="text-unnumbered-4">
<p>
Un <code>iterator</code> (et sa version constante <code>const_iterator</code>) permet de parcourir un
container du début à la fin en renvoyant un pointeur vers l&rsquo;objet
sélectionné. Un <code>const_iterator</code>, contrairement à un <code>iterator</code>, donne un accès
uniquement en lecture à l&rsquo;élément &ldquo;pointé&rdquo;. Ainsi, un parcours avec des
<code>const_iterator</code> maintient la constance de l&rsquo;objet et ne permettra pas de le
modifier. C&rsquo;est pourquoi un container &ldquo;<code>const</code>&rdquo; peut être parcouru par des
<code>const_iterator</code> et non par des <code>iterator</code>. De manière générale, quand on a le
choix entre des <code>iterator</code> ou des <code>const_iterator</code>, il faut toujours privilégier
les <code>const_iterator</code> car ils rendent la section de code à laquelle ils servent
plus générique (applicable aux containers constants ou non).
</p>

<p>
Appliqué au containers de la STL, on trouve ainsi les méthodes
</p>

<ul class="org-ul">
<li><code>begin()</code> qui retourne un <code>iterator</code> pointant sur le premier élément,
</li>

<li><code>end()</code> qui retourne un <code>iterator</code> pointant juste &ldquo;après&rdquo; le dernier élément,
</li>

<li>l&rsquo;opérateur <code>++</code> qui permet d&rsquo;incrémenter l&rsquo;<code>iterator</code> en le faisant
passer à l&rsquo;élément suivant.
</li>
</ul>

<p>
À titre d&rsquo;exemple, le programme suivant explicite leur utilisation
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;vector&gt;</span>
<span class="org-preprocessor">#include</span> <span class="org-string">&lt;iostream&gt;</span>

<span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">string</span>&gt; <span class="org-function-name">set_vector</span>()
{
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">string</span>&gt; <span class="org-variable-name">v</span>;
  v.push_back(<span class="org-string">"John"</span>);
  v.push_back(<span class="org-string">"Deuf"</span>);
  <span class="org-keyword">return</span> v;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-keyword">const</span> <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">string</span>&gt; <span class="org-variable-name">myVector</span>(<span class="org-type">set_vector</span>());

  <span class="org-comment-delimiter">// </span><span class="org-comment">ne compile pas car myVector est const</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">std::vector&lt;string&gt;::iterator itVector;</span>
  <span class="org-constant">std</span>::<span class="org-constant">vector</span>&lt;<span class="org-type">string</span>&gt;::<span class="org-type">const_iterator</span> <span class="org-variable-name">itVector</span>;

  <span class="org-keyword">for</span> (itVector = myVector.begin(); itVector != myVector.end(); ++itVector)
    cout &lt;&lt; *itVector &lt;&lt; endl;
  <span class="org-keyword">return</span> 0;
}
</pre>
</div>

<p>
Dans le même esprit, il existe également les contreparties <code>reverse_iterator</code> et
<code>const_reverse_iterator</code> qui parcourent l&rsquo;instance de la fin vers le début.
</p>
</div>
</div>
</div>
</body>
</html>
