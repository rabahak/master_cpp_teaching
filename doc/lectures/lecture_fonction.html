<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Rappels sur les fonctions</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<link rel="stylesheet" href="../stylesheets/styles.css">
                 <link rel="stylesheet" href="../stylesheets/org-pygments.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
</a><a href="lecture_pointeur.html">Pointeurs, références & allocation dynamique </a><a href="lecture_fonction.html">Rappels sur les fonctions </a><a href="lecture_specificite_c++.html">Les spécificités du C++ </a><a href="lecture_struct_class.html">Structures et classes </a><a href="lecture_encapsulation.html">Encapsulation des données </a><a href="lecture_constructeur.html">Notions de constructeur et de destructeur </a><a href="lecture_amitie.html">Fonctions et classes amies </a><a href="lecture_surcharge.html">Surcharge d'opérateur </a><a href="lecture_heritage.html">Héritage </a><a href="lecture_template.html">Notions de patrons de fonctions et de classes </a><a href="lecture_librairie_standard.html">Introduction à la librairie standard STL </a><a href=""></a><hr/><a href="annexe_compilation.html">Compilation et directives de préprocesseur </a><a href="annexe_convention_ecriture.html">Convention d'écriture et organisation des programmes </a><a href="annexe_cout_cin.html">Écriture/lecture sur l'entrée/sortie standard </a><a href="annexe_variable_statique.html">Les membres données statiques </a><a href="annexe_enum_typedef.html">Utilisation de enum et de typedef </a>
                    <hr/>
                    <a href="../../index.html">Retour menu principal</a>
</div>
<div id="content">
<h1 class="title">Rappels sur les fonctions</h1><hr/>

<div id="outline-container-unnumbered-1" class="outline-2">
<h2 id="unnumbered-1">Syntaxe</h2>
<div class="outline-text-2" id="text-unnumbered-1">
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">type_retourn&#233;</span> <span class="org-function-name">nom_fonction</span>(..., <span class="org-type">type_argument</span> <span class="org-variable-name">nom_argument</span>, ...)
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">Op&#233;rations avec les arguments</span>
  <span class="org-keyword">return</span> variable_retourn&#233;e;
}
</pre>
</div>

<p>
Exemple :
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">double</span> <span class="org-function-name">norme</span>(<span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">b</span>)
{
  <span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">resultat</span> = <span class="org-constant">std</span>::sqrt(a*a +b*b);
  <span class="org-keyword">return</span> resultat;  <span class="org-comment-delimiter">// </span><span class="org-comment">ou directement return std::sqrt (a*a + b*b);</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-2" class="outline-2">
<h2 id="unnumbered-2">Prototype de fonction</h2>
<div class="outline-text-2" id="text-unnumbered-2">
<p>
Le prototype indique au compilateur que la fonction prototypée existe, mais que
sa définition interviendra après son appel.
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">type_retourn&#233;</span> <span class="org-function-name">nom_fonction</span>(..., <span class="org-type">type_argument</span> <span class="org-variable-name">nom_argument</span>, ...);
</pre>
</div>

<p>
Exemple:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">double</span> <span class="org-function-name">norme</span>(<span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">b</span>); <span class="org-comment-delimiter">// </span><span class="org-comment">NB attention au point virgule</span>

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">x</span> = 2.5, <span class="org-variable-name">y</span> = 3.4;
  cout &lt;&lt; norme(x,y) &lt;&lt; endl;
}

<span class="org-type">double</span> <span class="org-function-name">norme</span>(<span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">a</span>, <span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">b</span>)
{
  <span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">resultat</span> = <span class="org-constant">std</span>::sqrt(a*a +b*b);
  <span class="org-keyword">return</span> resultat;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-unnumbered-3" class="outline-2">
<h2 id="unnumbered-3">Modification de variables via l&rsquo;utilisation d&rsquo;une fonction</h2>
<div class="outline-text-2" id="text-unnumbered-3">
<p>
Une fonction en C/C++, dans son utilisation la plus commune <i>i.e.</i> argument
transmis par valeur comme dans l&rsquo;exemple précédent, <b>ne modifie aucune variable
en argument</b>. La fonction utilise ses arguments pour créer, par exemple, une
<b>nouvelle valeur</b> qu&rsquo;elle retourne (la valeur <code>resultat</code> dans notre
exemple). Plus précisément, lors de l&rsquo;appel d&rsquo;une fonction, par exemple <code>norme
(4, 5)</code>, <code>Norme</code> crée deux variables locales <code>a</code> et <code>b</code> et réalise les
opérations de recopie suivantes: <code>a = 4</code> et <code>b = 5</code>. De même, en déclarant deux
variables <code>double x = 4.1;</code> et <code>double y = 5.6;</code>, l&rsquo;appel à la fonction <code>norme
(x, y)</code> entrainera la création de deux nouvelles variables locales <code>a</code> et <code>b</code> en
assignant leurs valeurs <code>a = x</code> et <code>b = y</code>. La fonction ne possède que <b>les
valeurs</b> de x et y; ainsi utilisée, elle ne pourra jamais modifier <code>x</code> et <code>y</code>.
</p>
</div>

<div id="outline-container-unnumbered-4" class="outline-3">
<h3 id="unnumbered-4">Argument transmis par adresse</h3>
<div class="outline-text-3" id="text-unnumbered-4">
<p>
Imaginons qu&rsquo;au lieu de transmettre des valeurs à la fonction, on transmette des
adresses ou des pointeurs qui contiennent une adresse. La fonction crée toujours
deux variables <code>a</code> et <code>b</code> au moment de son appel et copie dans ces deux
variables les adresses utilisées lors de l&rsquo;appel de la fonction. La fonction
<code>norme</code> se réécrit ainsi
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">double</span> <span class="org-function-name">norme</span>(<span class="org-keyword">const</span> <span class="org-type">double</span> *<span class="org-variable-name">a</span>, <span class="org-keyword">const</span> <span class="org-type">double</span> *<span class="org-variable-name">b</span>)
{
  <span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">resultat</span> = <span class="org-constant">std</span>::sqrt((*a)*(*a) + (*b)*(*b));
  <span class="org-keyword">return</span> resultat;
}
</pre>
</div>

<p>
que l&rsquo;on appelera au sein du programme principal <i>via</i> l&rsquo;instruction suivante
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">x</span> = 2.5, <span class="org-variable-name">y</span> = 3.4;
  cout &lt;&lt; norme(&amp;x, &amp;y) &lt;&lt; endl;
}
</pre>
</div>

<p>
On ne travaille plus avec les valeurs de <code>x</code> et <code>y</code> qui sont ponctuellement
<code>4.1</code> et <code>5.6</code> mais avec les données de <code>x</code> et <code>y</code> <i>i.e.</i> les 01001&#x2026; qui
composent <code>x</code> et <code>y</code>. On peut donc modifier ces données au sein de la fonction,
car on travaille directement avec elles et non avec leurs simples valeurs
recopiées.
</p>

<p>
La solution proposée présente néanmoins quelques inconvénients
</p>

<ul class="org-ul">
<li>d&rsquo;une part, la syntaxe est lourde en raison de l&rsquo;emploi de l&rsquo;opérateur <code>*</code>
  devant les paramètres,
</li>

<li>d&rsquo;autre part, la syntaxe est dangereuse lors de l&rsquo;appel de la fonction,
puisqu&rsquo;il faut systématiquement penser à utiliser l&rsquo;opérateur <code>&amp;</code> devant les
paramètres. Un oubli devant une variable de type entier et la valeur de
l&rsquo;entier est utilisée à la place de son adresse dans la fonction appelée.
</li>
</ul>

<p>
Le C++ permet de résoudre ces problèmes à l&rsquo;aide des références
</p>
</div>
</div>

<div id="outline-container-unnumbered-5" class="outline-3">
<h3 id="unnumbered-5">Argument transmis par référence</h3>
<div class="outline-text-3" id="text-unnumbered-5">
<p>
Comme nous venons de le rappeler, en langage C, les arguments et la valeur de
retour d&rsquo;une fonction sont transmis par valeur y compris lors de la transmission
par adresse puisque les valeurs de pointeurs sont recopiées. Le C++ peut
entièrement prendre en charge la transmission par adresse à travers
l&rsquo;utilisation des références. Le principal intérêt de la notion de référence est
qu&rsquo;elle laisse le compilateur mettre en œuvre &ldquo;les mécanismes&rdquo; adaptés au
transfert par adresse. Il n&rsquo;est plus alors nécessaire de passer par des
pointeurs. L&rsquo;utilisateur de la fonction (qui n&rsquo;est pas nécessairement celui qui
l&rsquo;a écrite) n&rsquo;a, dès lors, plus à connaitre la nature des arguments à
transmettre (une variable ou son adresse).
</p>

<p>
L&rsquo;exemple précédent devient
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">double</span> <span class="org-function-name">norme</span>(<span class="org-keyword">const</span> <span class="org-type">double</span> &amp;<span class="org-variable-name">a</span>, <span class="org-keyword">const</span> <span class="org-type">double</span> &amp;<span class="org-variable-name">b</span>)
{
  <span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">resultat</span> = <span class="org-constant">std</span>::sqrt(a*a + b*b);
  <span class="org-keyword">return</span> resultat;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-keyword">const</span> <span class="org-type">double</span> <span class="org-variable-name">x</span> = 2.5, <span class="org-variable-name">y</span> = 3.4;
  cout &lt;&lt; norme(x,y) &lt;&lt; endl;
}
</pre>
</div>

<p>
Dans l&rsquo;instruction
</p>

<div class="org-src-container">

<pre class="src src-c++"><span class="org-type">double</span> <span class="org-function-name">norme</span>(<span class="org-keyword">const</span> <span class="org-type">double</span> &amp;<span class="org-variable-name">a</span>, <span class="org-keyword">const</span> <span class="org-type">double</span> &amp;<span class="org-variable-name">b</span>);
</pre>
</div>

<p>
la notation <code>double &amp;a</code> signifie que <code>a</code> est une information de type <code>double</code>
transmise par référence. On notera que, dans la fonction <code>norme</code>, est utilisé le
symbole <code>a</code> pour désigner cette variable et non l&rsquo;opérateur d&rsquo;indirection <code>*</code>.
</p>

<p>
Cette amélioration est extrêmement importante du point de vue des
performances. Il est ainsi fortement recommandé de passer par référence tous les
paramètres dont la copie peut prendre beaucoup de temps tels que les tableaux et
plus encore les instances de classe (en pratique, seuls les types de base du
langage pourront être passés par valeur). Le gain en temps du fait de ne plus
créer de copie d&rsquo;objet, devient non négligeable <i>a fortiori</i>, lors d&rsquo;appels
successifs de la fonction.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
